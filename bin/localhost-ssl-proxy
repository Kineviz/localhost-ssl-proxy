#!/usr/bin/env node

"use strict";

const fs = require("fs");
const path = require("path");
const express = require("express");
const serveIndex = require("serve-index");
const httpProxy = require("http-proxy");

const chalk = require("chalk");
const devcert = require("devcert");

const { exists, absolutePath, program } = require("../lib/commandline");
const StaticPort = 9099;

program.parse(process.argv);

const opts = program.opts();

if (opts.config && exists(opts.config)) {
  try {
    opts.config = JSON.parse(
      fs.readFileSync(absolutePath(opts.config), "utf8")
    );
  } catch (error) {
    console.log(chalk.red(error));
    process.exit(1);
  }
} else {
  delete opts.config;
}

const enableCors = function (req, res) {
  if (req.headers["access-control-request-method"]) {
    res.setHeader(
      "access-control-allow-methods",
      req.headers["access-control-request-method"]
    );
  }

  if (req.headers["access-control-request-headers"]) {
    res.setHeader(
      "access-control-allow-headers",
      req.headers["access-control-request-headers"]
    );
  }

  if (req.headers.origin) {
    res.setHeader("access-control-allow-origin", req.headers.origin);
  } else {
    res.setHeader("access-control-allow-origin", "*");
  }

  res.setHeader("access-control-allow-credentials", "true");
};

function getBool(val) {
  if (String(val).toLowerCase() === "true") {
    return true;
  }
  if (String(val).toLowerCase() === "false") {
    return false;
  }
  return val;
}

function getOption(val) {
  let tmpVal = typeof val === "string" ? val.trim() : val;
  if (/^=/gi.test(tmpVal)) {
    return tmpVal.replace(/^=/gi, "");
  }
  return tmpVal;
}

function handleResponse(proxyRes, res, req, bodyBuffer, staticPath) {
  res.setHeader("content-type", proxyRes.headers["content-type"]);
  res.writeHead(proxyRes.statusCode);

  let body = bodyBuffer.toString();

  body = body.replace(/src[ ]*=[ ]*(\\*["'`])\//gim, `src=\$1${staticPath}/`);
  body = body.replace(/src[ ]*:[ ]*(\\*["'`])\//gim, `src:\$1${staticPath}/`);
  body = body.replace(/href[ ]*=[ ]*(\\*["'`])\//gim, `href=\$1${staticPath}/`);
  body = body.replace(/href[ ]*:[ ]*(\\*["'`])\//gim, `href:\$1${staticPath}/`);

  res.write(Buffer.from(body));
  res.end();
}

const config = opts.config || { "localhost-ssl-proxy": opts };
const configItems = Object.keys(config);
configItems.forEach(function (name, index) {
  const options = config[name] || {};
  const hostname = getOption(options.hostname || opts.hostname);
  const port = Number(getOption(options.port || opts.port));
  const targetPort = Number(getOption(options.targetPort || opts.targetPort));
  const targetHostname = getOption(options.DNS || opts.DNS || "localhost");
  const getBoolProp = (prop) =>
    getBool(options[prop] !== undefined ? options[prop] : opts[prop]);

  let onlyWS = getBoolProp("onlyWS");
  let useSSL = getBoolProp("useSSL");
  let useCORS = getBoolProp("useCORS");
  let proxySSL = getBoolProp("proxySSL") || port === 443;
  let staticPath = `/${getOption(options.staticPath || opts.staticPath).replace(
    /^\//gi,
    ""
  )}`;
  let staticDir = getOption(options.staticDir || opts.staticDir);
  let expressApp = null;

  if (staticDir && staticPath) {
    let app = express();
    expressApp = app;
    app.disable("x-powered-by");
    app.set("trust proxy", 1); // trust first proxy
    app.set("port", StaticPort);
    app.use(function (req, res, next) {
      enableCors(req, res);
      next();
    });

    app.use(["/"], express.static(staticDir, { index: false }));
    app.use(["/"], serveIndex(staticDir, { icons: true }));
    app.listen(app.get("port"), () => {
      console.log(
        `The static server run on http://localhost:${app.get("port")}`
      );
    });
  }

  let sessionName = getOption(options.sessionName || opts.sessionName);

  const proxyConfig = {
    xfwd: true,
    ws: true,
    changeOrigin: true,
    target: {
      host: hostname,
      port: port,
      protocol: proxySSL ? "https:" : "http:",
    },
    //custom options
    sessionName,
    useSSL,
    useCORS,
    name,
    proxySSL,
    targetHostname,
  };

  if (proxySSL) {
    proxyConfig.rejectUnauthorized = false;
    proxyConfig.secure = false;
  }

  if (useCORS) {
    //remove cookie domain and path
    proxyConfig.cookieDomainRewrite = {
      "*": "",
    };
    proxyConfig.cookiePathRewrite = {
      "*": "",
    };
    // proxyConfig.headers = {

    // }
  }

  const createProxyServer = (serverOptions) => {
    const proxy = new httpProxy.createProxyServer(serverOptions);

    proxy.on("error", function (e) {
      console.error(
        chalk.red(
          `Request failed to ${serverOptions.target.host}:${
            serverOptions.target.port
          } : ${chalk.bold(e.code)}`
        )
      );
    });
    //set header for CORS
    let proxyCookiesMap = {};
    proxy.on("proxyRes", function (proxyRes, req, res) {
      serverOptions.useCORS && enableCors(req, res);
      const sc = proxyRes.headers["set-cookie"] || [];
      const cookiesRaw = !serverOptions.sessionName
        ? sc
        : sc.filter((s) => s.startsWith(serverOptions.sessionName));
      if (cookiesRaw.length > 0) {
        cookiesRaw
          .filter((s) => typeof s === "string")
          .forEach((cookie) => {
            const cookieName = cookie.split(";")[0].split("=")[0];
            proxyCookiesMap[cookieName] = cookie;
          });
      }

      if (req.staticPath === staticPath) {
        if (!/text|html|css/gi.test(proxyRes.headers["content-type"])) {
          return proxyRes.pipe(res);
        }
        let bodyBuffer = [];
        proxyRes.on("data", function (chunk) {
          bodyBuffer.push(chunk);
        });
        proxyRes.on("end", function () {
          handleResponse(proxyRes, res, req, bodyBuffer, staticPath);
        });
      }
    });

    proxy.on("proxyReq", function (proxyReq, req, res, options) {
      if (Object.keys(proxyCookiesMap).length > 0) {
        proxyReq.setHeader("Cookie", Object.values(proxyCookiesMap));
      }
    });

    const handleProxyWeb = function (req, res) {
      if (req.method === "OPTIONS") {
        serverOptions.useCORS && enableCors(req, res);
        res.writeHead(200);
        res.end();
        return;
      }
      if (req.url.includes(staticPath) && staticDir) {
        req.url = req.url.replace(staticPath, "");
        req.staticPath = staticPath;
        proxy.web(req, res, {
          target: {
            host: "localhost",
            port: StaticPort,
            protocol: "http:",
          },
          selfHandleResponse: true,
        });
      } else {
        proxy.web(req, res);
      }
    };

    let proxyServer = null;
    if (proxyConfig.ssl) {
      proxyServer = require("https").createServer(
        proxyConfig.ssl,
        handleProxyWeb
      );
    } else {
      proxyServer = require("http").createServer(handleProxyWeb);
    }

    proxyServer.on("upgrade", function (req, socket, head) {
      proxy.ws(req, socket, head);
    });

    proxyServer.listen(targetPort);

    const proxyProtocol = `${serverOptions.onlyWS ? "ws" : "http"}${
      serverOptions.proxySSL ? "s" : ""
    }`;
    const targetProtocol = `${serverOptions.onlyWS ? "ws" : "http"}${
      serverOptions.ssl ? "s" : ""
    }`;
    const isCors = serverOptions.useCORS ? "enable CORS" : "disable CORS";

    console.log(
      chalk.green(`Started <${chalk.bold(serverOptions.name)}> (${isCors})`)
    );
    console.log(
      chalk.yellow(
        `${proxyProtocol}://${hostname}:${port} → ${targetProtocol}://${targetHostname}:${targetPort}`
      )
    );

    if (staticDir && staticPath) {
      console.log(
        chalk.yellow(
          `http://localhost:${StaticPort} → ${targetProtocol}://${targetHostname}:${targetPort}/${staticPath}`
        )
      );
    }

    console.log(chalk.red("\nHit CTRL-C to stop the proxy server \n"));
  };

  if (useSSL) {
    devcert.certificateFor([targetHostname]).then(
      (ssl) => {
        proxyConfig.ssl = ssl;
        createProxyServer(proxyConfig);
      },
      (err) => {
        console.log(chalk.red(err.message));
        createProxyServer(proxyConfig);
      }
    );
  } else {
    createProxyServer(proxyConfig);
  }
});
