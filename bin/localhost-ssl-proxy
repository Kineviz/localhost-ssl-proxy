#!/usr/bin/env node

'use strict';

const fs = require("fs");
const httpProxy = require("http-proxy");
const chalk = require("chalk");
const devcert = require("devcert");

const { 
  exists,
  absolutePath,
  program
} = require("../lib/commandline");

program.parse(process.argv);

const opts = program.opts();
if(opts.config && exists(opts.config)) {
  opts.config = fs.readFileSync(absolutePath(opts.config),'utf8');
}else{
  delete opts.config;
}

const enableCors = function(req, res) {
  if (req.headers['access-control-request-method']) {
    res.setHeader('access-control-allow-methods', req.headers['access-control-request-method']);
  }

  if (req.headers['access-control-request-headers']) {
    res.setHeader('access-control-allow-headers', req.headers['access-control-request-headers']);
  }

  if (req.headers.origin) {
		res.setHeader('access-control-allow-origin', req.headers.origin);
	}else{
    res.setHeader('access-control-allow-origin', "*");
  }

  res.setHeader('access-control-allow-credentials', 'true');
};



const config = opts.config || {"localhost-ssl-proxy":opts};
Object.keys(config).forEach(function(name) {
  const options = config[name];
  const hostname = options.hostname || opts.hostname;
  const port = Number(options.port || opts.port);
  const targetPort = Number(options.targetPort || opts.targetPort);
  let  useSSL =  options.useSSL !== undefined ?  options.useSSL : opts.useSSL;
  useSSL = typeof(useSSL) === 'string' ? (String(useSSL).toLowerCase() === 'true' ? true: false) : useSSL;

  let  useCORS =  options.useCORS !== undefined ?  options.useCORS : opts.useCORS;
  useCORS = typeof(useCORS) === 'string' ? (String(useCORS).toLowerCase() === 'true' ? true: false) : useCORS;

  const proxyConfig = {
    xfwd: true,
    ws: true,
    target: {
      host: hostname,
      port: port
    }
  };

  if(useCORS){
    //remove cookie domain and path
    proxyConfig.cookieDomainRewrite = {
      "*": ""
    }
    proxyConfig.cookiePathRewrite = {
      "*": ""
    }
    // proxyConfig.headers = {

    // }
  }

  const createProxyServer = (serverOptions) =>{

    const proxy = new httpProxy.createProxyServer(serverOptions);

    proxy.on("error", function(e) {
      console.error(chalk.red(`Request failed to ${serverOptions.target.host}:${serverOptions.target.port} : ${chalk.bold(e.code)}`));
    })
    //set header for CORS
    let proxyCookie = null ;
    proxy.on("proxyRes", function(proxyRes, req, res) {
      enableCors(req, res);
      const sc = proxyRes.headers['set-cookie'] || [];
      const raw = sc.filter(s => s.startsWith('nsid'));
      if(raw.length) {
        proxyCookie = raw[0].split(';')[0];
      }
    });

    proxy.on('proxyReq', function(proxyReq, req, res, options) {
     if(proxyCookie) {
        proxyReq.setHeader('Cookie', proxyCookie);
      }
    });
    
    const handleProxyWeb = function (req, res) {
      if (req.method === 'OPTIONS') {
        enableCors(req, res);
        res.writeHead(200);
        res.end();
        return;
      }
      proxy.web(req, res);
    };
 
    const proxyServer = proxyConfig.ssl ? require('https').createServer(proxyConfig.ssl, handleProxyWeb) : require('http').createServer(handleProxyWeb);

    proxyServer.on('upgrade', function (req, socket, head) {
      proxy.ws(req, socket, head);
    });
    
    proxyServer.listen(targetPort);
    
    console.log(chalk.green(`Started ${chalk.bold(name)} : http://${hostname}:${port} â†’ http${serverOptions.ssl ? 's' : ''}://localhost:${targetPort} `));  
    console.log(chalk.red('\nHit CTRL-C to stop the server \n'));
  }


  if(useSSL){
     devcert.certificateFor(['localhost'])
     .then(ssl =>{
      proxyConfig.ssl = ssl;
      createProxyServer(proxyConfig)
     },err =>{
      createProxyServer(proxyConfig)
     })
  }else{
    createProxyServer(proxyConfig);
  }

 });
